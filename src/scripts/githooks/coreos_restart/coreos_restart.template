#=================================================================================
# CoreOS Restart - Generated by PandaHook https://github.com/pandastrike/panda-hook
#=================================================================================
# This Bash script controls the actions of a hook-server. While triggered by a git
# command, this server can taking any additional action possible on a Linux machine.

# Algorithm:
# (1) Perform a clone of the "bare" repo we just pushed to, creating a regular repo.
# (2) Use the *.service files in the regular repo to re-deploy CoreOS services.

#===============================================================================
# Modules
#===============================================================================
# Core Libraries
fs = require "fs"
{resolve, join} = require "path"

# Panda Strike Libraries
Configurator = require "panda-config"                         # configuration
{chdir, read, write, read_block, lines, times,
 readdir, shell, stat, sleep, merge} = require "fairmont"     # panda-utility belt

# Third Party Libraries
{call} = require "when/generator"                             # promise library
{promise} = require "when"
async = (require "when/generator").lift
{render} = require "mustache"                                 # templating


#===============================================================================
# Template Rendered Varialbes
#===============================================================================
repo_name = "{{{repo_name}}}"

repo_path = join process.env.HOME, "repos/#{repo_name}"
launch_path = join repo_path, "launch"


#===============================================================================
# Helpers
#===============================================================================
print_banner = (text) ->
  console.log "\n"
  console.log "==============================================================="
  console.log "#{text}"
  console.log "==============================================================="

get_dirs = async (path) ->
  file for file in (yield readdir path) when (yield stat (join path, file)).isDirectory()

pull_configuration = async () ->
  configurator = Configurator.make
    extension: ".yaml"
    format: "yaml"
    paths: [ repo_path ]

  config = configurator.make name: "huxley"
  yield config.load()

  return config.data

# Renders the templates as full text and then writes to file.
render_template = async (spec) ->
  # Find the template for this service
  template_path =  join repo_path, "launch", "#{spec.service_name}/#{spec.template_filename}"
  template = yield read template_path

  # Render.
  rendered_string = render template, spec

  # Write to file.
  yield write (resolve repo_path, "launch/#{spec.service_name}/#{spec.output_filename}"), rendered_string

#===============================================================================
# Main
#===============================================================================
call ->
  print_banner "Push Detected. Activating Githook."

  # First, determine the branch being pushed and checkout that one.  That information is available
  # from the standard input.
  #[ignore..., branch_name] = times (read_block lines process.stdin), 3
  #branch_name = yield branch_name
  branch_name = "feature/templates"

  # Cloning the (freshly updated) bare repo creates a regular one, the beta.  It has a working tree
  # so we can access its files to find services and make other edits that don't get committed to the user's repo.
  print_banner "Cloning Bare Repo"

  # But first, wipe away any old versions of the regular repo and clone from the updated bare repo.
  yield shell "rm -rf #{repo_path}"
  yield shell "/usr/bin/git clone -b #{branch_name} -- #{process.env.HOME}/repos/#{repo_name}.git #{repo_path}"



  # Determine which services should be restarted by searching the regular repo's "launch"
  # directory.  Every subdirectory there represents something that needs a restart.
  print_banner "Stopping Service(s)"

  services = yield get_dirs launch_path

  for service in services
    console.log "Stopping #{service}"
    command = "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null " +
              "-p {{{cluster_port}}} {{{cluster_address}}} " +
              "/usr/bin/fleetctl destroy #{service}.service;"
    yield shell command

  # It sometimes takes the CoreOS cluster a moment to register your command.
  # If we wait a few seconds, the service will properly begin the termination sequence
  # before registering the following "start" command.
  yield sleep 5000



  # Finally, bring the service(s) back online.
  print_banner "Restarting Service(s)"

  # Start by rendering the service templates
  config = yield pull_configuration()
  config.branch_name = branch_name

  for service in services
    # Grab configuration for specific service.  Merge upwards with app configuration.
    spec = merge config, config.services[service], {service_name: service}, repo_path: repo_path

    # Render Service File
    spec.template_filename = "#{service}.service.template"
    spec.output_filename = "#{service}.service"
    yield render_template spec

    # Render Dockerfile
    spec.template_filename = "Dockerfile.template"
    spec.output_filename = "Dockerfile"
    yield render_template spec


  # Don't forget to commit the rendered service files so the cluster can use them.
  try
    command = "GIT_DIR=#{join repo_path, ".git"} && " +
              "cd #{repo_path} && " +
              "git config --global user.email 'huxley@app.cluster' && " +
              "git config --global user.name 'huxley agent' && " +
              "git add -A && " +
              "git commit -m 'rendered templates'"
    yield shell command
  catch error
    console.log error


  for service in services
    # Wipe away the scratch space used by hook server.
    command = "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null " +
              "-p {{{cluster_port}}} {{{cluster_address}}} sudo rm -rf prelaunch/#{service}"
    yield shell command

    # Copy the service files to the scratch space on the cluster
    command = "scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null " +
              "-P {{{cluster_port}}} -r #{repo_path}/launch/#{service} " +
              "{{{cluster_address}}}:/home/core/prelaunch/"
    yield shell command

    # Use fleetctl to start the services.  Point it at the service files in the scratch space.
    console.log "Spinning Up #{service}"
    command = "/usr/bin/ssh -A -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null " +
              "-p {{{cluster_port}}} {{{cluster_address}}} " +
              "/usr/bin/fleetctl start prelaunch/#{service}/#{service}.service"
    yield shell command
